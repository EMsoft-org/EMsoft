! ###################################################################
! Copyright (c) 2014-2019, Marc De Graef/Carnegie Mellon University
! All rights reserved.
!
! Redistribution and use in source and binary forms, with or without modification, are
! permitted provided that the following conditions are met:
!
!     - Redistributions of source code must retain the above copyright notice, this list
!        of conditions and the following disclaimer.
!     - Redistributions in binary form must reproduce the above copyright notice, this
!        list of conditions and the following disclaimer in the documentation and/or
!        other materials provided with the distribution.
!     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names
!        of its contributors may be used to endorse or promote products derived from
!        this software without specific prior written permission.
!
! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
! ###################################################################

!--------------------------------------------------------------------------
! EMsoft:local.f90
!--------------------------------------------------------------------------
!
! MODULE: local
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief definitions of single and double precision, general constants and variables
!
!> @details
!> defines the kind-parameters for short and long integers, and single/double
!> precision reals, as well as a few other global variables (path variables etc).
!
!> @note all errorCode values in this file start with 999xxx 
!
!> @date 1/8/99   MDG 1.0 original
!> @date 5/6/01   MDG 2.0 f90
!> @date 11/27/01 MDG 2.1 added sgl and dbl kinds
!> @date 12/08/01 MDG 2.2 added CTEMsoft subroutine
!> @date 03/19/13 MDG 3.0 rewrite of entire package
!> @date 05/16/13 MDG 3.1 added stdout
!> @date 01/10/14 MDG 4.0 new version
!> @date 06/05/14 MDG 4.1 added comments about global variables in Release 3.0
!> @date 03/29/14 MDG 4.2 added path variable for .xtal files (which are now HDF5 files)
!> @date 04/05/15 MDG 4.3 added additional path variables and an EMsoft_path_init routine
!> @date 11/20/15 MDG 4.4 added UserXXX variables to EMSoftConfig.json file
!> @date 02/16/16 MDG 4.5 added path delimiter conversion routines for Windows implementation
!> @date 02/25/16 MDG 4.6 added automatic generation of .config/EMsoft/EMsoftConfig.json file
!> @date 07/02/16 MDG 5.0 replaced all remaining globals by function calls to please the intel compiler
!> @date 10/25/16 MDG 5.1 added functionality for initializing EMsoftConfig.json on Windows
!> @date 08/16/17 MDG 5.2 replaced all string constants by string constants declared in stringconstants.f90
!> @date 10/28/17 MDG 6.0 changed handling of config parameters to a single structure read in at program start
!--------------------------------------------------------------------------

!---------------------------
! THIS FILE IS AUTOMATICALLY GENERATED DURING CMAKE TIME. THE ORIGINAL FILE
! LOCATED AT @CTEMSoftLib_SOURCE_DIR@/local.f90.in
! YOU NEED TO MAKE CHANGES TO THAT FILE. ANY CHANGES MADE TO THIS FILE WILL
! BE OVER WRITTEN THE NEXT TIME CMAKE IS EXECUTED.
!---------------------------

module local

use stringconstants
use,intrinsic :: ISO_C_BINDING

!> @note This module must be "use"d by every program, subroutine, and function.
!> These are the only global variables used by the EMsoft package.

! The entire EMsoft package should be processor independent.  This can
! be accomplished by the use of the "kind" parameters.

! Define the "kind" parameters for single and double precision reals,
!> single precision real kind parameter
  integer,parameter                     :: sgl = SELECTED_REAL_KIND(p=6,r=37)
!> double precision real kind parameter
  integer,parameter                     :: dbl = SELECTED_REAL_KIND(p=13,r=200)
!DEC$ ATTRIBUTES DLLEXPORT :: sgl
!DEC$ ATTRIBUTES DLLEXPORT :: dbl

! Define the "kind" parameters for short and regular integers,
!> short integer kind parameter
  integer,parameter                     :: ish = SELECTED_INT_KIND(3)
!> long integer kind parameter
  integer,parameter                     :: irg = SELECTED_INT_KIND(9)
!> long long kind parameter
  integer,parameter                     :: ill = SELECTED_INT_KIND(12)
!DEC$ ATTRIBUTES DLLEXPORT :: ish
!DEC$ ATTRIBUTES DLLEXPORT :: irg
!DEC$ ATTRIBUTES DLLEXPORT :: ill

!> character type used for json routines
  integer,parameter :: jsonCK = selected_char_kind('DEFAULT')
!DEC$ ATTRIBUTES DLLEXPORT :: jsonCK

!> standard string length for filenames
  integer(kind=irg),parameter           :: fnlen = 512
!DEC$ ATTRIBUTES DLLEXPORT :: fnlen

!> counter for non-fatal error messages in handling of environment variables;
!> if this counter equals 0, then error warnings will be printed, otherwise not.
  integer(kind=irg)                     :: displayEMsoftWarningMessages = 0
  integer(kind=irg)                     :: displayConfigFileMissingMessage = 0
!DEC$ ATTRIBUTES DLLEXPORT :: displayEMsoftWarningMessages
!DEC$ ATTRIBUTES DLLEXPORT :: displayConfigFileMissingMessage

!> standard array size for all wrapper routine calls; applies to ipar, fpar, and spar arrays
  integer(c_int32_t),parameter          :: wraparraysize = 80
!DEC$ ATTRIBUTES DLLEXPORT :: wraparraysize

!> reserved IO unit identifiers for postscript (20) and data (21-23)
  integer(kind=irg), parameter          :: psunit = 20, dataunit = 21, dataunit2 = 22, dataunit3 = 23
!DEC$ ATTRIBUTES DLLEXPORT :: psunit
!DEC$ ATTRIBUTES DLLEXPORT :: dataunit
!DEC$ ATTRIBUTES DLLEXPORT :: dataunit2
!DEC$ ATTRIBUTES DLLEXPORT :: dataunit3

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------

! Configuration parameters structure  [new in Release 3.2]
! since this structure can also be generated external to EMsoft, we opt to make it a 
! list of NULL-terminated strings 
type ConfigStructureType
! configuration parameters read from the EMsoftConfig.json file
 character(fnlen)  :: EMsoftpathname
 character(fnlen)  :: EMXtalFolderpathname
 character(fnlen)  :: EMdatapathname
 character(fnlen)  :: EMtmppathname
 character(fnlen)  :: EMsoftLibraryLocation
 character(fnlen)  :: EMSlackWebHookURL
 character(fnlen)  :: EMSlackChannel
 character(fnlen)  :: UserName
 character(fnlen)  :: UserLocation
 character(fnlen)  :: UserEmail
 character(5)      :: EMNotify
 character(3)      :: Develop
 character(3)      :: Release
! other configuration parameters that may be needed in various programs but are not in the EMsoftConfig.json file
 character(fnlen)  :: h5copypath
 character(fnlen)  :: EMsoftplatform
 character(fnlen)  :: EMsofttestpath
 character(fnlen)  :: EMsoftTestingPath
 character(fnlen)  :: EMsoftversion
 character(fnlen)  :: Configpath
 character(fnlen)  :: Templatepathname
 character(fnlen)  :: Resourcepathname
 character(fnlen)  :: Homepathname
 character(fnlen)  :: OpenCLpathname
 character(fnlen)  :: Templatecodefilename
 character(fnlen)  :: WyckoffPositionsfilename
 character(fnlen)  :: Randomseedfilename
 character(1)      :: EMsoftnativedelimiter
 character(fnlen)  :: strvals(wraparraysize)
end type ConfigStructureType

character(30),dimension(27) :: ConfigStructureNames = (/ "EMsoftpathname                ", &
                                                         "EMXtalFolderpathname          ", &
                                                         "EMdatapathname                ", &
                                                         "EMtmppathname                 ", &
                                                         "EMsoftLibraryLocation         ", &
                                                         "EMSlackWebHookURL             ", &
                                                         "EMSlackChannel                ", &
                                                         "UserName                      ", &
                                                         "UserLocation                  ", &
                                                         "UserEmail                     ", &
                                                         "EMNotify                      ", &
                                                         "Develop                       ", &
                                                         "Release                       ", &
                                                         "h5copypath                    ", &
                                                         "EMsoftplatform                ", &
                                                         "EMsofttestpath                ", &
                                                         "EMsoftTestingPath             ", &
                                                         "EMsoftversion                 ", &
                                                         "Configpath                    ", &
                                                         "Templatepathname              ", &
                                                         "Resourcepathname              ", &
                                                         "Homepathname                  ", &
                                                         "OpenCLpathname                ", &
                                                         "Templatecodefilename          ", &
                                                         "WyckoffPositionsfilename      ", &
                                                         "Randomseedfilename            ", &
                                                         "EMsoftnativedelimiter         " /)

!
contains

!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getNotify
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the EMNotify parameter
!
!> @param no input parameters
!
!> @date  08/18/17 MDG 1.0 new function
!--------------------------------------------------------------------------
recursive function EMsoft_getNotify() result(Notify)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getNotify

IMPLICIT NONE

character(fnlen) :: Notify, ep

ep = SC_EMNotify
Notify = EMsoft_getJSONparameter(ep, nobackslash=.TRUE.)

end function EMsoft_getNotify

!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getSlackWebHookURL
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the URL for the Slack Webhook to send message to the user
!
!> @param no input parameters
!
!> @date  08/18/17 MDG 1.0 new function
!--------------------------------------------------------------------------
recursive function EMsoft_getSlackWebHookURL() result(SlackWebHookURL)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getSlackWebHookURL

IMPLICIT NONE

character(fnlen) :: SlackWebHookURL, ep

ep = SC_EMSlackWebHookURL
SlackWebHookURL = EMsoft_getJSONparameter(ep, nobackslash=.TRUE.)

end function EMsoft_getSlackWebHookURL

!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getSlackChannel
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the URL for the Slack Webhook to send message to the user
!
!> @param no input parameters
!
!> @date  08/18/17 MDG 1.0 new function
!--------------------------------------------------------------------------
recursive function EMsoft_getSlackChannel() result(SlackChannel)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getSlackChannel

IMPLICIT NONE

character(fnlen) :: SlackChannel, ep

ep = SC_EMSlackChannel
SlackChannel = EMsoft_getJSONparameter(ep, nobackslash=.TRUE.)

end function EMsoft_getSlackChannel

!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getEMsoftplatform
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the EMsoftplatform
!
!> @param no input parameters
!
!> @date  07/02/16 MDG 1.0 new function
!--------------------------------------------------------------------------
recursive function EMsoft_getEMsoftplatform() result(platform)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getEMsoftplatform

IMPLICIT NONE

character(fnlen) :: platform

platform = "@CMAKE_SYSTEM_NAME@"

end function EMsoft_getEMsoftplatform

!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_geth5copypath
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the location of the h5copy program
!
!> @param no input parameters
!
!> @date  08/18/16 MDG 1.0 new function
!--------------------------------------------------------------------------
recursive function EMsoft_geth5copypath() result(h5copypath)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_geth5copypath

IMPLICIT NONE

character(fnlen) :: h5copypath

if (trim(EMsoft_getEMsoftplatform()).eq.SC_Windows) then
  h5copypath = "@HDF5_INSTALL@"//SC_h5copy//".exe"
else
  h5copypath = "@HDF5_INSTALL@"//SC_h5copy
end if

end function EMsoft_geth5copypath

!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getEMsofttestpath
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the EMsofttestpath variable
!
!> @param no input parameters
!
!> @date  07/02/16 MDG 1.0 new function
!--------------------------------------------------------------------------
recursive function EMsoft_getEMsofttestpath() result(testpath)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getEMsofttestpath

IMPLICIT NONE

character(fnlen) :: testpath, binarypath
character(1)     :: EMsoftnativedelimiter

EMsoftnativedelimiter = EMsoft_getEMsoftnativedelimiter()

binarypath = "@EMsoft_BINARY_DIR@"

testpath = trim(EMsoft_toNativePath(binarypath))&
           //EMsoftnativedelimiter//SC_Testing&
           //EMsoftnativedelimiter//SC_Temporary

end function EMsoft_getEMsofttestpath

!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getEMsoftHDFtest
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the EMsoftHDFtest environment variable 
!
!> @param no input parameters
!
!> @date  07/02/16 MDG 1.0 new function
!> @date  02/27/19 MDG 2.0 add functionality for environment variables
!--------------------------------------------------------------------------
recursive function EMsoft_getEMsoftHDFtest() result(doHDFtest)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getEMsoftHDFtest

use, intrinsic :: iso_fortran_env , only: error_unit, wp => real64

IMPLICIT NONE

logical                                 :: doHDFtest
character(fnlen)                        :: envParam, envReturn

envParam = 'EMsoftHDFtest'
call getenv(trim(envParam),envReturn)
doHDFtest = .FALSE.
if (trim(envReturn).ne.'') then 
  doHDFtest = .TRUE.
end if 

end function EMsoft_getEMsoftHDFtest

!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getEMsoftTestingPath
!
!> @brief Returns the path to the EMsoft binary directory
!
!> @param no input parameters
!--------------------------------------------------------------------------
recursive function EMsoft_getEMsoftTestingPath() result(buildpath)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getEMsoftTestingPath

IMPLICIT NONE

character(fnlen) :: buildpath

buildpath = "@EMsoft_TESTING_DIR@"

end function EMsoft_getEMsoftTestingPath

!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getEMsoftversion
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the Version Information
!
!> @param no input parameters
!
!> @date  07/02/16 MDG 1.0 new function
!--------------------------------------------------------------------------
recursive function EMsoft_getEMsoftversion() result(version)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getEMsoftversion

IMPLICIT NONE

character(20) :: version

version = "@EMsoft_VER_MAJOR@_@EMsoft_VER_MINOR@_@EMsoft_VER_PATCH@_@EMsoft_VERSION_TWEAK@"

end function EMsoft_getEMsoftversion


!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getEMsoftRevision
!
!> @author 
!
!> @brief returns the Git Hash of the current commit.
!
!> @param no input parameters
!
!> @date  
!--------------------------------------------------------------------------
recursive function EMsoft_getEMsoftRevision() result(revision)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getEMsoftRevision

IMPLICIT NONE

character(40) :: revision

revision = "@EMsoft_GIT_HASH@"

end function EMsoft_getEMsoftRevision

!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getEMsoftBuildDate
!
!> @author 
!
!> @brief returns the Git Hash of the current commit.
!
!> @param no input parameters
!
!> @date  
!--------------------------------------------------------------------------
recursive function EMsoft_getEMsoftBuildDate() result(buildDate)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getEMsoftBuildDate

IMPLICIT NONE

character(24) :: buildDate

buildDate = "@EMsoft_BUILD_TIMESTAMP@"

end function EMsoft_getEMsoftBuildDate


!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getEMsoftnativedelimiter
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the native delimiter for file paths
!
!> @param no input parameters
!
!> @date  07/02/16 MDG 1.0 new function
!--------------------------------------------------------------------------
recursive function EMsoft_getEMsoftnativedelimiter() result(EMsoftnativedelimiter)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getEMsoftnativedelimiter

IMPLICIT NONE

character(1)  :: EMsoftnativedelimiter

if (trim(EMsoft_getEMsoftplatform()).eq.SC_Windows) then
  EMsoftnativedelimiter = '\'
else
  EMsoftnativedelimiter = '/'
end if

end function EMsoft_getEMsoftnativedelimiter


!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getConfigpath
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the path for the configuration file
!
!> @param no input parameters
!
!> @date  07/02/16 MDG 1.0 new function
!--------------------------------------------------------------------------
recursive function EMsoft_getConfigpath() result(configpath)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getConfigpath

IMPLICIT NONE

character(fnlen)  :: configpath

character(fnlen)  :: dirstring
character(1)      :: EMsoftnativedelimiter

! determine the pathname delimiter character
EMsoftnativedelimiter = EMsoft_getEMsoftnativedelimiter()

! get the user's home directory to prepend to the config file name
dirstring = EMsoft_getUserHomePath()

configpath = trim(dirstring)//EMsoftnativedelimiter//SC_config//EMsoftnativedelimiter//SC_EMsoft

end function EMsoft_getConfigpath


!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getEMsoftpathname
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the EMsoftpathname variable from the EMsoftconfig.json file
!
!> @param no input parameters
!
!> @date  07/02/16 MDG 1.0 new function
!> @date  02/27/19 MDG 2.0 add functionality for environment variables
!--------------------------------------------------------------------------
recursive function EMsoft_getEMsoftpathname() result(EMsoftpathname)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getEMsoftpathname

use, intrinsic :: iso_fortran_env , only: error_unit, wp => real64

IMPLICIT NONE

character(fnlen)                        :: EMsoftpathname, ep, envParam, envReturn
integer                                 :: l, status

ep = SC_EMsoftpathname
EMsoftpathname = EMsoft_getJSONparameter(ep)

if (trim(EMsoftpathname).eq.'tryEnvironmentVariable') then 
  envParam = 'EMSOFTPATHNAME'
  call getenv(trim(envParam),envReturn)
  if (trim(envReturn).ne.'') then 
    EMsoftpathname = trim(envReturn)
    l = len(trim(EMsoftpathname))
    if (EMsoftpathname(l:l).ne.'/') EMsoftpathname = trim(EMsoftpathname)//'/'
  else
    write (error_unit,"(A)") 'EMsoftpathname was not defined in the json file'
    write (error_unit,"(A)") 'EMSOFTPATHNAME environment variable was NOT defined as a backup.'
    status = 999001
    write (error_unit,"(' status = ',I10)") status
    STOP 999001
  end if
end if 

end function EMsoft_getEMsoftpathname


!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getEMdatapathname
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the EMdatapathname variable from the EMsoftconfig.json file
!
!> @param no input parameters
!
!> @date  07/02/16 MDG 1.0 new function
!> @date  02/27/19 MDG 2.0 add functionality for environment variables
!--------------------------------------------------------------------------
recursive function EMsoft_getEMdatapathname() result(EMdatapathname)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getEMdatapathname

use, intrinsic :: iso_fortran_env , only: error_unit, wp => real64

IMPLICIT NONE

character(fnlen)                        :: EMdatapathname, ep, envParam, envReturn
integer                                 :: l

ep = SC_EMdatapathname
EMdatapathname = EMsoft_getJSONparameter(ep)

if (trim(EMdatapathname).eq.'tryEnvironmentVariable') then 
  envParam = 'EMDATAPATHNAME'
  call getenv(trim(envParam),envReturn)
  if (trim(envReturn).ne.'') then 
    EMdatapathname = trim(envReturn)
    l = len(trim(EMdatapathname))
    if (EMdatapathname(l:l).ne.'/') EMdatapathname = trim(EMdatapathname)//'/'
  else
    if (displayEMsoftWarningMessages.eq.0) then 
      write (error_unit,"(A)") 'EMdatapathname was not defined in the json file'
      write (error_unit,"(/A)") '  WARNING: EMDATAPATHNAME environment variable was NOT defined as a backup.'
      write (error_unit,"(A/)") '     ----> using absolute path convention'
      displayEMsoftWarningMessages = displayEMsoftWarningMessages+1
    end if
    EMdatapathname = ''
  end if
end if 

end function EMsoft_getEMdatapathname

!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getEMXtalFolderpathname
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the EMXtalFolderpathname variable from the EMsoftconfig.json file
!
!> @param no input parameters
!
!> @date  08/15/17 MDG 1.0 new function
!> @date  03/02/19 MDG 2.0 add functionality for environment variables
!--------------------------------------------------------------------------
recursive function EMsoft_getEMXtalFolderpathname() result(EMXtalFolderpathname)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getEMXtalFolderpathname

use, intrinsic :: iso_fortran_env , only: error_unit, wp => real64

IMPLICIT NONE

character(fnlen)                        :: EMXtalFolderpathname, ep, envParam, envReturn
integer                                 :: l

ep = SC_EMXtalFolderpathname
EMXtalFolderpathname = EMsoft_getJSONparameter(ep)

if (trim(EMXtalFolderpathname).eq.'tryEnvironmentVariable') then 
  envParam = 'EMXTALFOLDERPATHNAME'
  call getenv(trim(envParam),envReturn)
  if (trim(envReturn).ne.'') then 
    EMXtalFolderpathname = trim(envReturn)
    l = len(trim(EMXtalFolderpathname))
    if (EMXtalFolderpathname(l:l).ne.'/') EMXtalFolderpathname = trim(EMXtalFolderpathname)//'/'
  else
    if (displayEMsoftWarningMessages.eq.0) then 
      write (error_unit,"(A/)") '  WARNING: Unable to find definition for EMXtalFolderpathname'
      write (error_unit,"(A/)") '  WARNING: EMXTALFOLDERPATHNAME environment variable was NOT defined as a backup.'
      write (error_unit,"(A/)") '     ----> using absolute path convention'
      displayEMsoftWarningMessages = displayEMsoftWarningMessages+1
    end if
    EMXtalFolderpathname = ''
  end if
end if 

end function EMsoft_getEMXtalFolderpathname


!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getEMtmppathname
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the EMtmppathname variable from the EMsoftconfig.json file
!
!> @param no input parameters
!
!> @date  07/02/16 MDG 1.0 new function
!> @date  03/02/19 MDG 2.0 add functionality for environment variables
!--------------------------------------------------------------------------
recursive function EMsoft_getEMtmppathname() result(EMtmppathname)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getEMtmppathname

use, intrinsic :: iso_fortran_env , only: error_unit, wp => real64

IMPLICIT NONE

character(fnlen)                        :: EMtmppathname, ep, envParam, envReturn
integer                                 :: l

ep = SC_EMtmppathname
EMtmppathname = EMsoft_getJSONparameter(ep)

if (trim(EMtmppathname).eq.'tryEnvironmentVariable') then 
  envParam = 'EMTMPPATHNAME'
  call getenv(trim(envParam),envReturn)
  if (trim(envReturn).ne.'') then 
    EMtmppathname = trim(envReturn)
    l = len(trim(EMtmppathname))
    if (EMtmppathname(l:l).ne.'/') EMtmppathname = trim(EMtmppathname)//'/'
  else
    if (displayEMsoftWarningMessages.eq.0) then 
      write (error_unit,"(/A)") '  WARNING: Unable to find definition for EMtmppathname'
      write (error_unit,"(/A)") '  WARNING: EMTMPPATHNAME environment variable was NOT defined as a backup.'
      write (error_unit,"(A/)") '     ----> using absolute path convention'
      displayEMsoftWarningMessages = displayEMsoftWarningMessages+1
    end if
    EMtmppathname = ''
  end if
end if 

end function EMsoft_getEMtmppathname

!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getUsername
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the Username variable from the EMsoftconfig.json file
!
!> @param no input parameters
!
!> @date  07/02/16 MDG 1.0 new function
!> @date  03/02/19 MDG 2.0 add functionality for environment variables
!--------------------------------------------------------------------------
recursive function EMsoft_getUsername() result(username)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getUsername

IMPLICIT NONE

character(fnlen)                        :: username, ep, envParam, envReturn, loginname

ep = SC_UserName
username = EMsoft_getJSONparameter(ep, nobackslash=.TRUE.)

if (trim(username).eq.'tryEnvironmentVariable') then 
  envParam = 'USERNAME'
  call getenv(trim(envParam),envReturn)
  if (trim(envReturn).ne.'') then 
    username = trim(envReturn)
  else
    call getlog(loginname)
    username = trim(loginname)
  end if
end if 

end function EMsoft_getUsername

!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getUserlocation
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the userlocation variable from the EMsoftconfig.json file
!
!> @param no input parameters
!
!> @date  07/02/16 MDG 1.0 new function
!> @date  03/02/19 MDG 2.0 add functionality for environment variables
!--------------------------------------------------------------------------
recursive function EMsoft_getUserlocation() result(userlocation)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getUserlocation

IMPLICIT NONE

character(fnlen)                        :: userlocation, ep, envParam, envReturn, hostname

ep = SC_UserLocation
userlocation = EMsoft_getJSONparameter(ep, nobackslash=.TRUE.)

if (trim(userlocation).eq.'tryEnvironmentVariable') then 
  envParam = 'USERlocation'
  call getenv(trim(envParam),envReturn)
  if (trim(envReturn).ne.'') then 
    userlocation = trim(envReturn)
  else
    call hostnm(hostname)
    userlocation = trim(hostname)
  end if
end if 

end function EMsoft_getUserlocation


!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getUseremail
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the useremail variable from the EMsoftconfig.json file
!
!> @param no input parameters
!
!> @date  07/02/16 MDG 1.0 new function
!> @date  03/02/19 MDG 2.0 add functionality for environment variables
!--------------------------------------------------------------------------
recursive function EMsoft_getUseremail() result(useremail)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getUseremail


IMPLICIT NONE

character(fnlen)                        :: useremail, ep, envParam, envReturn, hostname

ep = SC_UserEmail
useremail = EMsoft_getJSONparameter(ep, nobackslash=.TRUE.)

if (trim(useremail).eq.'tryEnvironmentVariable') then 
  useremail = 'undefined'
end if

end function EMsoft_getUseremail


!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getEMdevelop
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief check whether or not the Develop keyword is present in the config file
!
!> @param no input parameters
!
!> @date  08/18/16 MDG 1.0 new function
!> @date  09/10/19 MDG 1.1 add environment variable option for EMdevelop
!--------------------------------------------------------------------------
recursive function EMsoft_getEMdevelop() result(EMdevelop)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getEMdevelop

IMPLICIT NONE

character(fnlen)                        :: EMstring, ep, envParam, envReturn
logical                                 :: EMdevelop

! default: not in developer mode
EMdevelop = .FALSE.

ep = SC_Develop
EMstring = EMsoft_getJSONparameter(ep, nobackslash=.TRUE.)

if (trim(EMstring).eq.'Yes') then 
  EMdevelop = .TRUE.
else if (trim(EMstring).eq.'tryEnvironmentVariable') then
       envParam = 'EMdevelop'
       call getenv(trim(envParam),envReturn)
       if (trim(envReturn).eq.'Yes') EMdevelop = .TRUE.
     end if

end function EMsoft_getEMdevelop

!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getRelease
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief check whether or not the Release keyword is present in the config file
!
!> @param no input parameters
!
!> @date  10/28/17 MDG 1.0 new function
!--------------------------------------------------------------------------
recursive function EMsoft_getRelease() result(Release)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getRelease

IMPLICIT NONE

character(fnlen)                        :: EMstring, ep
logical                                 :: Release

ep = SC_Release
EMstring = EMsoft_getJSONparameter(ep, nobackslash=.TRUE.)

Release = .FALSE.
if (trim(EMstring).eq.'Yes') Release = .TRUE.

end function EMsoft_getRelease

!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getJSONparameter
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the ep variable from the EMsoftconfig.json file
!
!> @param ep JSON variable name string
!
!> @date  07/02/16 MDG 1.0 new function
!> @date  08/19/16 MDG 1.1 modification for Develop check
!> @date  12/03/16 MDG 1.2 added check for final delimiter
!> @date  08/15/17 MDG 1.3 changed default behavior for empty JSON parameter strings
!> @date  02/27/19 MDG 2.0 add code to allow for operation without config json file
!--------------------------------------------------------------------------
recursive function EMsoft_getJSONparameter(ep, nobackslash) result(param)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getJSONparameter

use json_module

use, intrinsic :: iso_fortran_env , only: error_unit, wp => real64

IMPLICIT NONE

character(fnlen),INTENT(IN)             :: ep
character(fnlen)                        :: param
logical,INTENT(IN),optional             :: nobackslash

type(json_file)                         :: json
integer(kind=irg)                       :: error_cnt, slen
character(kind=jsonCK,len=:),allocatable:: cval
character(fnlen)                        :: jsonfilename, jsonname
logical                                 :: found, jexists, bs
character(1)                            :: EMsoftnativedelimiter

bs = .TRUE.
if (present(nobackslash)) then
  if (nobackslash.eqv..TRUE.) bs = .FALSE.
end if 

! determine the pathname delimiter character
EMsoftnativedelimiter = EMsoft_getEMsoftnativedelimiter()

jsonfilename = SC_jsonfilename
jsonname =  trim(EMsoft_getConfigpath())//EMsoftnativedelimiter//trim(jsonfilename)

! test whether or not this file actually exists
inquire(file=trim(jsonname),exist=jexists)

if (jexists) then
! initialize the json state variables
  error_cnt = 0
  call json_initialize()
  if (json_failed()) then
    call json_print_error_message(error_unit)
    stop
  end if

! and load the file
  call json%load_file(filename = trim(jsonname))
  if (json_failed().eqv..TRUE.) then    !if there was an error reading the file
    call json_print_error_message(error_unit)
    stop
  end if

  call json%get(trim(ep), cval, found)
  if (.not. found) then
   if (trim(ep).eq.SC_Develop) then
    param = trim(ep)
   else
    write(error_unit,'(A)') 'WARNING: USER='//trim(EMsoft_getUser())
    write(error_unit,'(A)') 'WARNING: field '//trim(ep)//' not found in json file: '//trim(jsonname)
    write(error_unit,'(A)') 'WARNING: continuing with empty parameter value for '//trim(ep)
    param = ''
   end if
  else
    param = trim(cval)
  end if

! and make sure there is a terminating EMsoftnativedeliter character, except when the 
! field has zero length, in which case some other default behavior will be assumed; this 
! last case was added on 08/15/17 to offer an alternative file location mechanism to the user, namely
! either a full path declaration or the current working folder, to complement the default
! behavior which is to prepend the contents of the datapathname configuration variable.
  slen = len(trim(cval))
  if ((slen.ne.0).and.(bs.eqv..TRUE.)) then 
    if (cval(slen:slen).ne.EMsoftnativedelimiter) then
      param = trim(cval)//EMsoftnativedelimiter
    end if
  end if
else
  if (displayConfigFileMissingMessage.eq.0) then 
    write(error_unit,'(A)') '  WARNING: USER='//trim(EMsoft_getUser())
    write(error_unit,'(A)') '  WARNING: file '//trim(jsonname)//' not found '
    write(error_unit,'(A/)') '  -----> Trying environment variables next ... '
    displayConfigFileMissingMessage = 1
  end if
  param = 'tryEnvironmentVariable'
end if


end function EMsoft_getJSONparameter


!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getTemplatepathname
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the templatepathname
!
!> @param no input parameters
!
!> @date  07/02/16 MDG 1.0 new function
!> @date  05/11/17 MDG 1.1 added support for JSON template files
!--------------------------------------------------------------------------
recursive function EMsoft_getTemplatepathname(json) result(templatepathname)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getTemplatepathname

logical,INTENT(IN),OPTIONAL             :: json

character(fnlen)                        :: templatepathname

if (present(json)) then
  if (json.eqv..TRUE.) then
    templatepathname = trim(EMsoft_getEMsoftpathname())//SC_JSONTemplates//'/'
  else
    templatepathname = trim(EMsoft_getEMsoftpathname())//SC_NamelistTemplates//'/'
  end if
else
  templatepathname = trim(EMsoft_getEMsoftpathname())//SC_NamelistTemplates//'/'
end if

end function EMsoft_getTemplatepathname

!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getwikipathname
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the wikipathname
!
!> @param no input parameters
!
!> @date  07/02/16 MDG 1.0 new function
!> @date  05/11/17 MDG 1.1 added support for JSON template files
!--------------------------------------------------------------------------
recursive function EMsoft_getwikipathname() result(wikipathname)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getwikipathname

character(fnlen)                        :: wikipathname

wikipathname = trim(EMsoft_getEMsoftpathname())//SC_wiki//'/'

end function EMsoft_getwikipathname

!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getResourcepathname
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the resourcepathname
!
!> @param no input parameters
!
!> @date  07/02/16 MDG 1.0 new function
!--------------------------------------------------------------------------
recursive function EMsoft_getResourcepathname() result(resourcepathname)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getResourcepathname

character(fnlen)                        :: resourcepathname

resourcepathname = trim(EMsoft_getEMsoftpathname())//SC_resources//'/'

end function EMsoft_getResourcepathname

!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getUserHomePath
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the resourcepathname
!
!> @param no input parameters
!
!> @date  10/25/16 MDG 1.0 new function
!--------------------------------------------------------------------------
recursive function EMsoft_getUserHomePath() result(userHomePathName)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getUserHomePath

character(fnlen)  :: userHomePathName
character(9)      :: Home
character(2)      :: HomeDrive

HomeDrive = ''
if (trim(EMsoft_getEMsoftplatform()).eq.SC_Windows) then
  Home = 'HOMEPATH'
  call getenv("HOMEDRIVE",HomeDrive)
else
  Home = 'HOME'
end if

call getenv(trim(Home),userHomePathName)
userHomePathName = trim(HomeDrive)//trim(userHomePathName)

end function EMsoft_getUserHomePath

!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getUserHomePath
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the resourcepathname
!
!> @param no input parameters
!
!> @date  10/25/16 MDG 1.0 new function
!--------------------------------------------------------------------------
recursive function EMsoft_getUser() result(userName)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getUser

character(fnlen)  :: userName
character(9)      :: User

User = 'USER'

call getenv(trim(User),userName)
userName = trim(userName)

end function EMsoft_getUser


!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getOpenCLpathname
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the openclpathname
!
!> @param no input parameters
!
!> @date  07/02/16 MDG 1.0 new function
!--------------------------------------------------------------------------
recursive function EMsoft_getOpenCLpathname() result(openclpathname)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getOpenCLpathname

character(fnlen)                        :: openclpathname

openclpathname = trim(EMsoft_getEMsoftpathname())//SC_opencl//'/'

end function EMsoft_getOpenCLpathname


!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getXtalpathname
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the xtalpathname
!
!> @param no input parameters
!
!> @date  07/02/16 MDG 1.0 new function
!> @date  08/15/17 MDG 1.1 removed need for xtal folder to be named XtalFolder
!--------------------------------------------------------------------------
recursive function EMsoft_getXtalpathname() result(xtalpathname)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getXtalpathname

character(fnlen)                        :: xtalpathname, p

xtalpathname = trim(EMsoft_getEMXtalFolderpathname())

end function EMsoft_getXtalpathname

!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getfftwWisdomfilename
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the filename of the fftw wisdom file
!
!> @param no input parameters
!
!> @date  01/29/19 MDG 1.0 new function
!--------------------------------------------------------------------------
recursive function EMsoft_getfftwWisdomfilename() result(fftwWisdomfilename)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getfftwWisdomfilename

character(fnlen)                        :: fftwWisdomfilename

fftwWisdomfilename = trim(EMsoft_getResourcepathname())//SC_fftwwisdomtxt

end function EMsoft_getfftwWisdomfilename


!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getTemplatecodefilename
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the templatecodefilename
!
!> @param no input parameters
!
!> @date  07/02/16 MDG 1.0 new function
!--------------------------------------------------------------------------
recursive function EMsoft_getTemplatecodefilename() result(templatecodefilename)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getTemplatecodefilename

character(fnlen)                        :: templatecodefilename

templatecodefilename = trim(EMsoft_getResourcepathname())//SC_templatecodestxt

end function EMsoft_getTemplatecodefilename

!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getwikicodefilename
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the wikicodefilename
!
!> @param no input parameters
!
!> @date  09/08/19 MDG 1.0 new function
!--------------------------------------------------------------------------
recursive function EMsoft_getwikicodefilename() result(wikicodefilename)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getwikicodefilename

character(fnlen)                        :: wikicodefilename

wikicodefilename = trim(EMsoft_getResourcepathname())//SC_wikicodestxt

end function EMsoft_getwikicodefilename

!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getWyckoffPositionsfilename
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the Wyckoff Positions filename
!
!> @param no input parameters
!
!> @date  09/05/16 MDG 1.0 new function
!--------------------------------------------------------------------------
recursive function EMsoft_getWyckoffPositionsfilename() result(WPfilename)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getWyckoffPositionsfilename

character(fnlen)                        :: WPfilename

WPfilename = trim(EMsoft_getResourcepathname())//SC_WyckoffPositionstxt

end function EMsoft_getWyckoffPositionsfilename


!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_getRandomseedfilename
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief returns the randomseedfilename
!
!> @param no input parameters
!
!> @date  07/02/16 MDG 1.0 new function
!--------------------------------------------------------------------------
recursive function EMsoft_getRandomseedfilename() result(randomseedfilename)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_getRandomseedfilename

character(fnlen)                        :: randomseedfilename

randomseedfilename = trim(EMsoft_getResourcepathname())//SC_RandomSeedsdata

end function EMsoft_getRandomseedfilename


!--------------------------------------------------------------------------
!
! SUBROUTINE: EMsoft
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief prints a copyright statement and the program name
!
!> @details prints a copyright statement as well as where the user can find the license information
!> This is then followed by the program name, a one-line description, and a time stamp.
!
!> @param progname program name string
!> @param progdesc program descriptor string
!> @param EMconfig configuration structure 
!> @param stdout optional output unit identifier
!> @param makeconfig optional passed on to EMsoft_path_init
!
!> @date  12/08/01 MDG 1.0 original
!> @date  03/19/13 MDG 2.0 minor modifications
!> @date  05/16/13 MDG 2.1 added timestamp and stdout
!> @date  01/10/14 MDG 3.0 new version
!> @date  06/05/14 MDG 4.0 progname and progdesc are now subroutine arguments; made stdout optional
!> @date  02/25/16 MDG 4.1 added config optional parameter
!> @date  10/28/17 MDG 5.0 added config structure parameter + initialization of its fields
!--------------------------------------------------------------------------

subroutine EMsoft(progname,progdesc,EMconfig,stdout,makeconfig)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft

IMPLICIT NONE

character(fnlen),INTENT(IN)           :: progname
character(fnlen),INTENT(IN)           :: progdesc
type(ConfigStructureType),INTENT(OUT),OPTIONAL :: EMconfig
integer(kind=irg),INTENT(IN),OPTIONAL :: stdout
logical,INTENT(IN),OPTIONAL           :: makeconfig

integer(kind=irg)                     :: std

 std = 6
 if (PRESENT(stdout)) std=stdout

! initialize all the fields of the EMconfig structure
if (present(EMconfig)) then
   EMconfig%EMsoftpathname = trim(EMsoft_getEMsoftpathname())
   EMconfig%EMXtalFolderpathname = trim(EMsoft_getEMXtalFolderpathname())
   EMconfig%EMdatapathname = trim(EMsoft_getEMdatapathname())
   EMconfig%EMtmppathname = trim(EMsoft_getEMtmppathname())
   EMconfig%EMsoftLibraryLocation = ''     ! this needs special handling for IDL and WorkBench
   EMconfig%EMSlackWebHookURL = trim(EMsoft_getSlackWebHookURL())
   EMconfig%EMSlackChannel = trim(EMsoft_getSlackChannel())
   EMconfig%UserName = trim(EMsoft_getUsername())
   EMconfig%UserLocation = trim(EMsoft_getUserlocation())
   EMconfig%UserEmail = trim(EMsoft_getUseremail())
   EMconfig%EMNotify = trim(EMsoft_getNotify())
   if (EMsoft_getEMdevelop().eqv..TRUE.) then 
      EMconfig%Develop = 'Yes' 
    else 
      EMconfig%Develop = 'No'
    end if
    if (EMsoft_getRelease().eqv..TRUE.) then 
      EMconfig%Release = 'Yes' 
    else 
      EMconfig%Release = 'No'
    end if
  ! other configuration parameters that may be needed in various program but are not in the EMsoftConfig.json file
   EMconfig%h5copypath = "@HDF5_INSTALL@"//SC_h5copy
   EMconfig%EMsoftplatform = "@CMAKE_SYSTEM_NAME@"
   EMconfig%EMsofttestpath = trim(EMsoft_getEMsofttestpath())
   EMconfig%EMsoftTestingPath = "@EMsoft_TESTING_DIR@"
   EMconfig%EMsoftversion = trim(EMsoft_getEMsoftversion())
   EMconfig%Configpath = trim(EMsoft_getConfigpath())
   EMconfig%Templatepathname = trim(EMsoft_getTemplatepathname())
   EMconfig%Resourcepathname = trim(EMsoft_getResourcepathname())
   EMconfig%Homepathname = trim(EMsoft_getUserHomePath())
   EMconfig%OpenCLpathname = trim(EMsoft_getOpenCLpathname())
   EMconfig%Templatecodefilename = trim(EMsoft_getTemplatecodefilename())
   EMconfig%WyckoffPositionsfilename = trim(EMsoft_getWyckoffPositionsfilename())
   EMconfig%Randomseedfilename = trim(EMsoft_getRandomseedfilename())
   EMconfig%EMsoftnativedelimiter = EMsoft_getEMsoftnativedelimiter()
end if 

 write (std,"(//1x,'Copyright (C) 2001-2019 Marc De Graef Research Group/CMU')") 
 write (std,"(1x,'EMsoft comes with ABSOLUTELY NO WARRANTY.')")
 write (std,"(1x,'This is free software, and you are welcome to redistribute it')")
 write (std,"(1x,'under certain conditions; see License.txt file for details.'//)")

 write (std,"(1x,'Program name         : ',A)") trim(progname)
 write (std,"(1x,'Purpose              : ',A)") trim(progdesc)
 write (std,"(1x,'Platform             : ',A)") "@CMAKE_SYSTEM_NAME@"
 write (std,"(1x,'Source code version  : ',A)") trim(EMsoft_getEMsoftversion())
 write (std,"(1x,'Source code Revision : ',A)") trim(EMsoft_getEMsoftRevision())
 write (std,"(1x,'Build Date/Time      : ',A/)") trim(EMsoft_getEMsoftBuildDate())

 write (std,"(1x,'See https://github.com/EMsoft-org/EMsoft/wiki for selected help pages.'/)")

 call timestamp(std)
 write (std,"(1x,/)")

 if (present(makeconfig)) then ! we need to (re-)create the EMsoftConfig.json file...
    if (makeconfig.eqv..TRUE.) then
      call EMsoft_path_init(makeconfig)
    end if
 end if

end subroutine EMsoft


!--------------------------------------------------------------------------
! EMsoft:local:EMsoft_toNativePath.f90
!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_toNativePath
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert a path string from the native format to the other one
!
!> @param inpath input path string
!
!> @date  02/16/16 MDG 1.0 new routine
!--------------------------------------------------------------------------
function EMsoft_toNativePath(inpath) result(outpath)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_toNativePath

IMPLICIT NONE

character(fnlen),INTENT(IN)        :: inpath
character(fnlen)                   :: outpath

integer(kind=irg)                    :: i, slen
character(1)                         :: todelim, fromdelim, c

slen = len(inpath)
outpath = ''
todelim = EMsoft_getEMsoftnativedelimiter()

if (todelim.eq.'\') then
  fromdelim = '/'
else
  fromdelim = '\'
end if

do i=1,slen
  c = inpath(i:i)
  if (c.eq.fromdelim) c = todelim
  outpath(i:i) = c
end do

end function EMsoft_toNativePath


!--------------------------------------------------------------------------
! EMsoft:local:EMsoft_fromNativePath.f90
!--------------------------------------------------------------------------
!
! FUNCTION: EMsoft_fromNativePath
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert a path string to the native format on this platform
!
!> @param inpath input path string
!
!> @date  02/16/16 MDG 1.0 original version
!--------------------------------------------------------------------------
function EMsoft_fromNativePath(inpath) result(outpath)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_fromNativePath

IMPLICIT NONE

character(fnlen),INTENT(IN)          :: inpath
character(fnlen)                     :: outpath

integer(kind=irg)                    :: i, slen
character(1)                         :: todelim, fromdelim, c

slen = len(inpath)
outpath = ''
fromdelim = EMsoft_getEMsoftnativedelimiter()

if (fromdelim.eq.'/') then
  todelim = '\'
else
  todelim = '/'
end if

do i=1,slen
  c = inpath(i:i)
  if (c.eq.fromdelim) c = todelim
  outpath(i:i) = c
end do

end function EMsoft_fromNativePath


!--------------------------------------------------------------------------
! EMsoft:local:EMsoft_path_init.f90
!--------------------------------------------------------------------------
!
! SUBROUTINE: EMsoft_path_init
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief Reads environment variables and sets appropriate path variables
!
!> @details This routine is called at the start of every EMsoft program; first,
!> we check to see whether or not the configuration file exists in .config/EMsoft.
!> If it exists, we simply parse the file and initialize various path parameters;
!> if it does not exist, then we create it with some default parameters and ask the
!> user for some others.
!
!> @param config optional
!
!> @date  05/05/15 MDG 1.0 new routine
!> @date  09/26/15 MDG 1.1 added .json config support
!> @date  11/20/15 MDG 1.2 added UserXXX variable support to json file
!> @date  02/25/16 MDG 1.3 removed support for environment variables; added creation of EMsoftConfig.json file
!> @date  02/25/16 MDG 1.4 added optional config parameter
!> @date  10/07/16 MDG 1.5 modified creation of configuration file for new split Public/Private develop setup
!> @date  08/31/18 MDG 1.6 replaced 'mv' command by 'ren' for Windows platform
!--------------------------------------------------------------------------

subroutine EMsoft_path_init(config)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_path_init

IMPLICIT NONE

logical,INTENT(IN),OPTIONAL             :: config

character(fnlen)                        :: pathstring, dirstring, ep, EMsoftpathname, EMdatapathname, &
                                           username, userlocn, useremail
integer(kind=irg)                       :: i, error_cnt
logical                                 :: found, fexists, jexists
character(fnlen)                        :: confname, emsoftname, jsonname, jsonfilename, fname, cwd, &
                                           dirname, library, dataname, xtalname, platform
character(3)                            :: release, develop
character(len=1)                        :: edp, tab, yesno, EMsoftnativedelimiter

edp = '"'
tab = CHAR(9)
yesno = 'n'
EMsoftpathname = ''
EMdatapathname = ''

! default names for the json configuration file
confname = SC_config
emsoftname = SC_EMsoft
jsonfilename = SC_jsonfilename

! determine the pathname delimiter character
EMsoftnativedelimiter = EMsoft_getEMsoftnativedelimiter()

! get the config file name
jsonname = trim(EMsoft_getConfigpath())//EMsoftnativedelimiter//trim(jsonfilename)

! test whether or not this file actually exists
inquire(file=trim(jsonname),exist=jexists)

! if this routine is called with config=.TRUE. parameter, then that means that we
! must create a new EMsoftConfig.json file if it doesn't already exist; we will inform
! the user if it does exist, and rename the existing file
if (present(config)) then
  if (config.eqv..TRUE.) then

    if (jexists) then
      write (*,*) '-------'
      write (*,*) 'WARNING: An older configuration file already exists in the .config/EMsoft folder'
      write (*,*) '         The existing file will be renamed and a new file created.'
      write (*,"(/'          Do you want to continue ? (y/n) ',$)")
      read(*,"(A1)") yesno
      if (yesno.eq.'n') then
        stop 'program terminated'
      end if
      write (*,*) '         Renaming old file to ',trim(jsonname)//'.save'
      write (*,*) '         Creating new configuration file'
      write (*,*) '-------'
      platform = EMsoft_getEMsoftplatform()
      if (trim(platform).ne.'Windows') then   ! use the UNIX rename command 'mv oldname newname'
        call system('mv '//trim(jsonname)//' '//trim(jsonname)//'.save')
      else   ! on Windows the file rename command is 'ren oldname newname'
        call system('ren '//trim(jsonname)//' '//trim(jsonname)//'.save')
      end if
    end if

! look for the .config/EMsoft/EMsoftConfig.json file one step at a time
    dirstring = EMsoft_getUserHomePath()
    call chdir(trim(dirstring))

! check for the .config folder
    dirname = trim(dirstring)//EMsoftnativedelimiter//trim(confname)
    inquire(file=trim(dirname),exist=fexists)
    if (.not.(fexists)) then
      call system('mkdir '//trim(dirname))
      write (*,*) trim(dirname),' folder did not exist and has been created'
    end if
    call chdir(trim(dirname))

! check for the EMsoft folder
    dirname = trim(dirname)//EMsoftnativedelimiter//SC_EMsoft
    inquire(file=trim(dirname),exist=fexists)
    if (.not.(fexists)) then
      call system('mkdir '//trim(dirname))
      write (*,*) trim(dirname),' folder did not exist and has been created'
    end if
    call chdir(trim(dirname))

! check whether or not the tmp folder exists...
    fname = trim(dirname)//EMsoftnativedelimiter//SC_tmp
    inquire(file=trim(fname),exist=fexists)
    if (.not.(fexists)) then
      call system('mkdir '//trim(fname))
      write (*,*) trim(fname),' folder did not exist and has been created'
    end if

! ok, so we have created the correct folder structure; now we need to generate the
! skeleton EMsoftConfig.json file, which then needs to be edited by the user

    release = 'No'
    develop = 'No'

! generate the json file
    open(unit=dataunit,file=trim(jsonname),status='new',form='formatted')
    write (dataunit,"('{')")
    write (dataunit,"(A,A,'EMsoftpathname',A,': ',A,A,A,',')") tab, edp, edp, edp, &
       trim(EMsoft_getUserHomePath())//EMsoftnativedelimiter,edp
    write (dataunit,"(A,A,'EMXtalFolderpathname',A,': ',A,A,A,',')") tab, edp, edp, edp, &
       trim(EMsoft_getUserHomePath())//EMsoftnativedelimiter,edp
    write (dataunit,"(A,A,'EMdatapathname',A,': ',A,A,A,',')") tab, edp, edp, edp, &
       trim(EMsoft_getUserHomePath())//EMsoftnativedelimiter,edp
    write (dataunit,"(A,A,'EMtmppathname',A,': ',A,A,A,',')") tab, edp, edp, edp, &
       trim(fname)//EMsoftnativedelimiter,edp
    write (dataunit,"(A,A,'EMsoftLibraryLocation',A,': ',A,A,A,',')") tab, edp, edp, edp, &
       trim(EMsoft_getUserHomePath())//EMsoftnativedelimiter,edp
    write (dataunit,"(A,A,'Release',A,': ',A,A,A,',')") tab, edp, edp, edp, trim(release), edp
    write (dataunit,"(A,A,'Develop',A,': ',A,A,A,',')") tab, edp, edp, edp, trim(develop), edp

    write (*,*) '------'
    write (*,*) 'Please respond to the following questions (each entry < 132 characters)'
    write(*,"(A,$)") '  Enter your user name : '
    read(*,"(A)") username
    write (dataunit,"(A,A,'UserName',A,': ',A,A,A,',')") tab, edp, edp, edp, trim(username), edp

    write(*,"(A,$)") '  Enter your email address : '
    read(*,"(A,$)") useremail
    write (dataunit,"(A,A,'UserEmail',A,': ',A,A,A,',')") tab, edp, edp, edp, trim(useremail), edp

    write(*,"(A,$)") '  Enter your affiliation : '
    read(*,"(A,$)") userlocn
    write (dataunit,"(A,A,'UserLocation',A,': ',A,A,A)") tab, edp, edp, edp, trim(userlocn), edp

    write (dataunit,"('}')")
    close(unit=dataunit,status='keep')

    write (*,"(/' A skeleton EMsoftConfig.json file has been created in your .config/EMsoft folder.')")
    write (*,"(' You will need to edit this file to change the parameters from their default values.')")
    write (*,"(' ')")
    write (*,"(' - EMsoftpathname should point to the top folder of your EMsoft installation.')")
    write (*,"(' - EMdatapathname should point to where you want to keep all EMsoft output files.')")
    write (*,"('   Note that this folder should NOT be inside the EMsoftpathname folder!')")
    write (*,"('   You may leave this variable undefined (empty string) to force programs to')")
    write (*,"('   generate all files in the current working folder or to use full path file names.')")
    write (*,"(' - EMXtalFolderpathname should point to the folder that will contain the *.xtal files.')")
    write (*,"(' - EMtmppathname should point to the tmp folder where the EMsoftConfig.json file is located.')")
    write (*,"(' - EMsoftLibraryLocation is needed only if you have a fully functional IDL installation; this')")
    write (*,"('   variable should then point to the location of the EMsoftLib.dylib or EMsoftLib.dll file.')")
    write (*,"(' - One of the variables Develop and Release should be set to Yes, the other to No; if you are')")
    write (*,"('   developing new EMsoft code using the EMsoftPrivate folder, then set Develop to Yes')")
    write (*,"('   and Release to No to indicate Debug mode. for regular users: Develop=No, Release=Yes')")
    write (*,"(' - EMNotify can be set to Slack or Email to send program completion messages to the user')")
    write (*,"(' - EMSlackWebHookURL and EMSlackChannel are used for Slack messages (see Package Configuration wiki)')")
    write (*,"(' ')")
    write (*,"(' Make sure that each non-empty pathname ends with /, even on Windows platforms ! ')")
    write (*,"(' ')")
    write (*,"(' Every EMsoft program will read this configuration file to figure out where things are located.'/)")

  end if
end if

end subroutine EMsoft_path_init


!--------------------------------------------------------------------------
!
! subroutine: timestamp
!
!> @author John Burkardt
!
!> @brief prints the current YMDHMS date as a time stamp.
!
!> @note  This code was originally distributed under the GNU LGPL license;
!> Original code at <https://people.sc.fsu.edu/~jburkardt/f_src/timestamp/timestamp.f90>
!> significantly modified and adapted for EMsoft needs.
!
!> @param stdout output unit identifier
!> @param timestring (output) string containing the time data
!> @param datestring (output) string containing the date data
!
!> @date 05/31/01  JB original
!> @date 05/01/13 MDG changed 'm' to 'mo' for month variable, and some other minor changes
!> @date 06/05/14 MDG added stdout as optional argument
!> @date 03/19/15 MDG added timestring and datestring optional arguments
!--------------------------------------------------------------------------
subroutine timestamp (stdout, timestring, datestring)
!DEC$ ATTRIBUTES DLLEXPORT :: timestamp

  IMPLICIT NONE

  integer(kind=irg),INTENT(IN),OPTIONAL    :: stdout
  character(len = 11),INTENT(OUT),OPTIONAL :: datestring
  character(len = 15),INTENT(OUT),OPTIONAL :: timestring

  integer(kind=irg)      :: std, d, h, mo, mm, n, s, values(8), y
  character ( len = 8 )  :: ampm, date
!  character ( len = 3 ), parameter, dimension(12) :: month = (/ &
!    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec' /)
  character ( len = 3 ), dimension(12) :: month
  character ( len = 10 ) :: time
  character ( len = 5 )  :: zone

  std = 6
  if (PRESENT(stdout)) std=stdout
  month = (/ &
    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec' /)
! this is the start of the original code
  call date_and_time ( date, time, zone, values )

  y = values(1)
  mo = values(2)
  d = values(3)
  h = values(5)
  n = values(6)
  s = values(7)
  mm = values(8)

  if ( h < 12 ) then
    ampm = 'AM'
  else if ( h == 12 ) then
    if ( n == 0 .and. s == 0 ) then
      ampm = 'Noon'
    else
      ampm = 'PM'
    end if
  else
    h = h - 12
    if ( h < 12 ) then
      ampm = 'PM'
    else if ( h == 12 ) then
      if ( n == 0 .and. s == 0 ) then
        ampm = 'Midnight'
      else
        ampm = 'AM'
      end if
    end if
  end if
! end of original code

  if ((.not.PRESENT(datestring)).and.(.not.PRESENT(timestring))) then
    write ( std, '(a1,a3,1x,i2,1x,i4,2x,i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) &
      ' ',month(mo), d, y, h, ':', n, ':', s, '.', mm, trim ( ampm )
  else
    if (PRESENT(datestring)) write (datestring, '(a,1x,i2,1x,i4)' ) month(mo), d, y
    if (PRESENT(timestring)) then
      write (timestring, '(i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) h,':',n,':',s,'.',mm,trim(ampm)
    end if
  end if

end subroutine timestamp



end module local
